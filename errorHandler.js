const DataBaseError = require("./errors/DataBaseError");
const { ValidationError } = require('yup');

module.exports.basicErrorHandler = (err, req, res, next) => { // ОБРОБНИК ПОМИЛОК
    if(err instanceof DataBaseError) {
        return res.status(404).send(err.message);
    }

    if(err instanceof ValidationError) {
        return res.status(400).send('Invalid data');
    }
}


/*

--- Що робити, якщо потрібно реалізувати обробку помилок?

1. Створити обробник помилок

Файл errorHandler.js:

module.exports.basicErrorHandler = (err, req, res, next) => { // ОБРОБНИК ПОМИЛОК

    // ТУТ БУДЕ ВІДБУВАТИСЬ ОБРОБКА ПОМИЛОК

}

2. Навісити обробник помилок ПІСЛЯ всіх ваших роутів в файлі app.js:

const { basicErrorHandler } = require('./errorHandler');
....РОУТИ...
app.use(basicErrorHandler);

Після виконання 2 кроку, всі ваші помилки, які потраплятимуть у контроллерах в блоці catch до методу next() -> прокидуватимуться до обробника помилок

3. Перевіряємо, яка саме помилка нам прийшла (instanceof), і, в залежності від типу помилки, закриваємо з'єднання з клієнтом з тим чи іншим кодом та повертаємо відповідне повідомлення про помилку



--- Для чого мені потрібні кастомні помилки?
Кастомна помилка потрібна для кращого розуміння, що за проблема у вас відбулась.
У назві і у повідомленні своєї власної, кастомної помилки ви можете закладати пояснення, що у вас відбулось.



--- Як створити кастомну помилку

1. Всі кастомні помилки, зазвичай, зберігаються у спеціальній папці - errors
Якщо у вас немає цієї папки - створіть

2. Вам потрібно описати клас помилки

class <назва_вашої_кастомної_помилки> extends Error {
    constructor(message) {
        super(message);
        this.message = <текст_повідомлення>
        // текст повідомлення має логічно пояснювати, що саме за помилка у вас сталася - це повідомлення може передаватися клієнту
    }
}

module.exports = <назва_вашої_кастомної_помилки>;

Після виконання цього кроку тепер ви можете цю кастомну помилку використовувати
Під кожну кастомну помилку - окремий файл

3. Наприклад, ви можете використовувати цю помилку у моделі або у контроллері

Приклад:

const DataBaseError = require('../errors/DataBaseError');

...........МОЖЕ ЙТИ ЯКИЙСЬ КОД........

module.exports.createThing = async (req, res, next) => {
    const { body } = req;
    try {
        const createdThing = await Thing.create(body);

        if(createdThing) {
            return res.status(201).send(createdThing);
            // якщо штука успішно створена - закриваємо з'єднання з клієнтом і передаємо йому створену у базі даних штуку
        } else {
            throw new DataBaseError();
            // в противному випадку, якщо штука не створена - прокидуємо свою кастомну помилку
            // message не передаємо, будемо використовувати те повідомлення, яке вказали у конструкторі
            // або, якщо вас не влаштовує message визначений при створенні кастомної помилки, ви можете визначити своє якесь власне повідомлення про помилку
        }
    } catch (error) {
        next(error);
    }
}

Кастомна помилка, яку ми прокидуємо - вона для нас, як для розробників зрозуміла
Ми просто за назвою помилки можемо зрозуміти, що саме пішло не так

- Обробник для DataBaseError всередині нашого обробника помилок виглядатиме ось таким чином:

module.exports.basicErrorHandler = (err, req, res, next) => { // ОБРОБНИК ПОМИЛОК
    if(err instanceof DataBaseError) {
        return res.status(404).send(err.message);
    }

    // ..... тут можуть бути ще якісь варіанти інших помилок
}

Тобто, якщо стається помилка DataBaseError - ми закриваємо з'єднання і повертаємо клієнту те повідомлення про помилку, яке ми визначали у конструкторі кастомної помилки


P.S. Глобально, кастомні помилки - помилки, які зрозумілі для вас та інших розробників

*/